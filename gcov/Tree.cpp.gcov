        -:    0:Source:Tree.cpp
        -:    1:#ifndef TREE_CPP
        -:    2:#define TREE_CPP
        -:    3:
        -:    4:#include "Tree.hpp"
        -:    5:#include <queue>
        -:    6:#include <stack>
        -:    7:#include <cmath>
        -:    8:#include <SFML/Graphics.hpp>
        -:    9:#include <iostream>
        -:   10:#include <sstream>
        -:   11:
        -:   12:namespace ariel {
        -:   13:
        -:   14:    template <typename T, size_t K>
        1:   15:    Tree<T, K>::Tree() : root(nullptr) {}
        -:   16:
        -:   17:    template <typename T, size_t K>
        1:   18:    Tree<T, K>::~Tree() {
        1:   19:        clear(root);
        1:   20:    }
        -:   21:
        -:   22:    template <typename T, size_t K>
        1:   23:    void Tree<T, K>::add_root(const T& key) {
        1:   24:        if (!root) {
        1:   25:            root = new Node(key);
        -:   26:        } else {
    #####:   27:            root->key = key;
        -:   28:        }
        1:   29:    }
        -:   30:
        -:   31:    template <typename T, size_t K>
        4:   32:    void Tree<T, K>::add_sub_node(Node* parent, const T& key) {
       4*:   33:        if (!parent) return;
        -:   34:
        6:   35:        for (size_t i = 0; i < K; ++i) {
        6:   36:            if (!parent->children[i]) {
        4:   37:                parent->children[i] = new Node(key);
        4:   38:                return;
        -:   39:            }
        -:   40:        }
    #####:   41:        std::cerr << "No empty slot to add sub node." << std::endl;
        -:   42:    }
        -:   43:
        -:   44:    template <typename T, size_t K>
        -:   45:    void Tree<T, K>::display() const {
        -:   46:        displayHelper(root, 0);
        -:   47:    }
        -:   48:
        -:   49:    template <typename T, size_t K>
        1:   50:    typename Tree<T, K>::Node* Tree<T, K>::get_root() const {
        1:   51:        return root;
        -:   52:    }
        -:   53:
        -:   54:    template <typename T, size_t K>
     1288:   55:    void Tree<T, K>::draw(sf::RenderWindow &window) const
        -:   56:    {
     1288:   57:        if (root) {
     1288:   58:            float initialDistance = window.getSize().y / 3;  // Initial distance from root to first level of children
     1288:   59:            drawNode(window, root, sf::Vector2f(window.getSize().x / 2, 50), 90, initialDistance, 0);
        -:   60:        }
     1288:   61:    }
        -:   62:
        -:   63:    template <typename T, size_t K>
        -:   64:    void Tree<T, K>::displayHelper(Node* node, int indent) const {
        -:   65:        if (!node) return;
        -:   66:        for (int i = 0; i < indent; ++i) std::cout << "  ";
        -:   67:        std::cout << node->key << std::endl;
        -:   68:        for (size_t i = 0; i < K; ++i) {
        -:   69:            displayHelper(node->children[i], indent + 1);
        -:   70:        }
        -:   71:    }
        -:   72:
        -:   73:    template <typename T, size_t K>
       11:   74:    void Tree<T, K>::clear(Node* node) {
       11:   75:        if (!node) return;
       15:   76:        for (size_t i = 0; i < K; ++i) {
       10:   77:            clear(node->children[i]);
        -:   78:        }
        5:   79:        delete node;
        -:   80:    }
        -:   81:
        -:   82:    template <typename T, size_t K>
     6440:   83:    void Tree<T, K>::drawNode(sf::RenderWindow& window, Node* node, sf::Vector2f position, float angle, float distance, int depth) const
        -:   84:    {
    6440*:   85:        if (!node) return;
        -:   86:
     6440:   87:        sf::CircleShape circle(20);
     6440:   88:        circle.setFillColor(sf::Color::Blue);
     6440:   89:        circle.setPosition(position.x - circle.getRadius(), position.y - circle.getRadius());
     6440:   90:        window.draw(circle);
        -:   91:
     6440:   92:        sf::Font font;
     6440:   93:        if (!font.loadFromFile("arial.ttf")) {
    #####:   94:            std::cerr << "Error loading font\n";
        -:   95:        }
     6440:   96:        sf::Text text;
     6440:   97:        text.setFont(font);
        -:   98:
        -:   99:        // Use std::ostringstream to convert the node's key to a string
     6440:  100:        std::ostringstream oss;
     6440:  101:        oss << node->key;
     6440:  102:        text.setString(oss.str());
        -:  103:
        -:  104:        // Set the text properties
     6440:  105:        text.setCharacterSize(20);
     6440:  106:        text.setFillColor(sf::Color::White);
     6440:  107:        text.setPosition(position.x - circle.getRadius() / 2, position.y - circle.getRadius() / 2);
     6440:  108:        window.draw(text);
        -:  109:
     6440:  110:        float new_distance = distance / 1.5f;  // Reduce distance for next level
     6440:  111:        float angleIncrement = 45.0f / (K - 1);  // Distribute angles for child nodes
        -:  112:
        -:  113:        // Draw all the nodes with the following order: Recursive (Parent Node -> Arrow to Child Node -> Child Node)
    19320:  114:        for (size_t i = 0; i < K; ++i) {
    12880:  115:            if (node->children[i]) {
     5152:  116:                float childAngle = angle + (i - (K / 2.0f)) * angleIncrement;
     5152:  117:                float rad = childAngle * 3.14159265359 / 180.0f;
     5152:  118:                sf::Vector2f new_position = position + sf::Vector2f(cos(rad) * distance, sin(rad) * distance);
        -:  119:
        -:  120:                // Draw the child node
     5152:  121:                drawNode(window, node->children[i], new_position, childAngle, new_distance, depth + 1);
     5152:  122:                drawArrow(window, position, new_position);  // Draw the arrow
        -:  123:
        -:  124:            }
        -:  125:        }
     6440:  126:    }
        -:  127:
        -:  128:    template <typename T, size_t K>
     5152:  129:    void Tree<T, K>::drawArrow(sf::RenderWindow &window, sf::Vector2f start, sf::Vector2f end) const
        -:  130:    {
        -:  131:        // Draw the main line
     5152:  132:        sf::Vertex line[] = {
        -:  133:            sf::Vertex(start),
        -:  134:            sf::Vertex(end)
        -:  135:        };
     5152:  136:        window.draw(line, 2, sf::Lines);
        -:  137:
        -:  138:        // Calculate the direction of the arrow
     5152:  139:        sf::Vector2f direction = end - start;
     5152:  140:        float length = std::sqrt(direction.x * direction.x + direction.y * direction.y);
     5152:  141:        direction /= length;
        -:  142:
        -:  143:        // Set the size of the arrowhead
     5152:  144:        float arrowSize = 10.0f;
        -:  145:        
        -:  146:        // Calculate the points of the arrowhead
     5152:  147:        sf::Vector2f arrowPoint1 = end - direction * arrowSize + sf::Vector2f(-direction.y, direction.x) * arrowSize * 0.5f;
     5152:  148:        sf::Vector2f arrowPoint2 = end - direction * arrowSize + sf::Vector2f(direction.y, -direction.x) * arrowSize * 0.5f;
        -:  149:
     5152:  150:        sf::Vertex arrowhead[] = {
        -:  151:            sf::Vertex(end),
        -:  152:            sf::Vertex(arrowPoint1),
        -:  153:            sf::Vertex(end),
        -:  154:            sf::Vertex(arrowPoint2)
        -:  155:        };
     5152:  156:        window.draw(arrowhead, 4, sf::Lines);
     5152:  157:    }
        -:  158:
        -:  159:    template <typename T, size_t K>
        2:  160:    typename Tree<T, K>::BFSIterator Tree<T, K>::begin_bfs() {
        2:  161:        return BFSIterator(root);
        -:  162:    }
        -:  163:
        -:  164:    template <typename T, size_t K>
       12:  165:    typename Tree<T, K>::BFSIterator Tree<T, K>::end_bfs() {
       12:  166:        return BFSIterator(nullptr);
        -:  167:    }
        -:  168:
        -:  169:    template <typename T, size_t K>
        -:  170:    typename Tree<T, K>::DFSIterator Tree<T, K>::begin_dfs() {
        -:  171:        return DFSIterator(root);
        -:  172:    }
        -:  173:
        -:  174:    template <typename T, size_t K>
        -:  175:    typename Tree<T, K>::DFSIterator Tree<T, K>::end_dfs() {
        -:  176:        return DFSIterator(nullptr);
        -:  177:    }
        -:  178:
        -:  179:    template <typename T, size_t K>
        -:  180:    typename Tree<T, K>::PreOrderIterator Tree<T, K>::begin_preorder() {
        -:  181:        return PreOrderIterator(root);
        -:  182:    }
        -:  183:
        -:  184:    template <typename T, size_t K>
        -:  185:    typename Tree<T, K>::PreOrderIterator Tree<T, K>::end_preorder() {
        -:  186:        return PreOrderIterator(nullptr);
        -:  187:    }
        -:  188:
        -:  189:    template <typename T, size_t K>
        -:  190:    typename Tree<T, K>::InOrderIterator Tree<T, K>::begin_inorder() {
        -:  191:        return InOrderIterator(root);
        -:  192:    }
        -:  193:
        -:  194:    template <typename T, size_t K>
        -:  195:    typename Tree<T, K>::InOrderIterator Tree<T, K>::end_inorder() {
        -:  196:        return InOrderIterator(nullptr);
        -:  197:    }
        -:  198:
        -:  199:    template <typename T, size_t K>
        -:  200:    typename Tree<T, K>::PostOrderIterator Tree<T, K>::begin_postorder() {
        -:  201:        return PostOrderIterator(root);
        -:  202:    }
        -:  203:
        -:  204:    template <typename T, size_t K>
        -:  205:    typename Tree<T, K>::PostOrderIterator Tree<T, K>::end_postorder() {
        -:  206:        return PostOrderIterator(nullptr);
        -:  207:    }
        -:  208:
        -:  209:    template <typename T, size_t K>
        1:  210:    typename Tree<T, K>::BFSIterator Tree<T, K>::myHeap()
        -:  211:    {
        -:  212:        if (K != 2) {
        -:  213:            throw std::invalid_argument("Tree is not binary");
        -:  214:        }
        -:  215:
        -:  216:        // Convert the binary tree to a vector
        1:  217:        std::vector<T> elements;
        1:  218:        std::queue<Node*> nodeQueue;
        1:  219:        if (root) {
        1:  220:            nodeQueue.push(root);
        -:  221:        }
        6:  222:        while (!nodeQueue.empty()) {
        5:  223:            Node* current = nodeQueue.front();
        5:  224:            nodeQueue.pop();
        5:  225:            elements.push_back(current->key);
       15:  226:            for (size_t i = 0; i < K; ++i) {
       10:  227:                if (current->children[i]) {
        4:  228:                    nodeQueue.push(current->children[i]);
        -:  229:                }
        -:  230:            }
        -:  231:        }
        -:  232:
        -:  233:        // Build a min heap from the elements
        1:  234:        std::make_heap(elements.begin(), elements.end(), std::greater<T>());
        -:  235:
        -:  236:        // Rebuild the tree as a min heap
        1:  237:        std::queue<Node**> pointerQueue;
        1:  238:        pointerQueue.push(&root);
        6:  239:        for (const T& element : elements) {
        5:  240:            Node** currentPointer = pointerQueue.front();
        5:  241:            pointerQueue.pop();
        5:  242:            *currentPointer = new Node(element);
        5:  243:            pointerQueue.push(&((*currentPointer)->children[0]));
        5:  244:            pointerQueue.push(&((*currentPointer)->children[1]));
        -:  245:        }
        -:  246:
        2:  247:        return this->begin_bfs();  // Return BFS iterator to the minimum heap
        1:  248:    }
        -:  249:
        -:  250:    // BFSIterator implementation
        -:  251:    template <typename T, size_t K>
       14:  252:    Tree<T, K>::BFSIterator::BFSIterator(Node* root) {
       14:  253:        if (root) {
        2:  254:            queue.push(root);
        -:  255:        }
       14:  256:    }
        -:  257:
        -:  258:    //TODO - Edit 
        -:  259:    template <typename T, size_t K>
       12:  260:    bool Tree<T, K>::BFSIterator::operator!=(const BFSIterator& other) const {
       12:  261:        return !queue.empty();
        -:  262:    }
        -:  263:
        -:  264:    template <typename T, size_t K>
       10:  265:    const T& Tree<T, K>::BFSIterator::operator*() const {
       10:  266:        return queue.front()->key;
        -:  267:    }
        -:  268:
        -:  269:    template <typename T, size_t K>
       10:  270:    typename Tree<T, K>::BFSIterator& Tree<T, K>::BFSIterator::operator++() {
       10:  271:        Node* current = queue.front();
       10:  272:        queue.pop();
       30:  273:        for (size_t i = 0; i < K; ++i) {
       20:  274:            if (current->children[i]) {
        8:  275:                queue.push(current->children[i]);
        -:  276:            }
        -:  277:        }
       10:  278:        return *this;
        -:  279:    }
        -:  280:
        -:  281:    // DFSIterator implementation
        -:  282:    template <typename T, size_t K>
        -:  283:    Tree<T, K>::DFSIterator::DFSIterator(Node* root) {
        -:  284:        if (root) {
        -:  285:            stack.push(root);
        -:  286:        }
        -:  287:    }
        -:  288:
        -:  289:    //TODO - Edit 
        -:  290:    template <typename T, size_t K>
        -:  291:    bool Tree<T, K>::DFSIterator::operator!=(const DFSIterator& other) const {
        -:  292:        return !stack.empty();
        -:  293:    }
        -:  294:
        -:  295:    template <typename T, size_t K>
        -:  296:    const T& Tree<T, K>::DFSIterator::operator*() const {
        -:  297:        return stack.top()->key;
        -:  298:    }
        -:  299:
        -:  300:    template <typename T, size_t K>
        -:  301:    typename Tree<T, K>::DFSIterator& Tree<T, K>::DFSIterator::operator++() {
        -:  302:        Node* current = stack.top();
        -:  303:        stack.pop();
        -:  304:        for (size_t i = K; i-- > 0;) {
        -:  305:            if (current->children[i]) {
        -:  306:                stack.push(current->children[i]);
        -:  307:            }
        -:  308:        }
        -:  309:        return *this;
        -:  310:    }
        -:  311:
        -:  312:    // PreOrderIterator implementation
        -:  313:    template <typename T, size_t K>
        -:  314:    Tree<T, K>::PreOrderIterator::PreOrderIterator(Node* root) {
        -:  315:        if (root) {
        -:  316:            stack.push(root);
        -:  317:        }
        -:  318:    }
        -:  319:
        -:  320:    //TODO - Edit 
        -:  321:    template <typename T, size_t K>
        -:  322:    bool Tree<T, K>::PreOrderIterator::operator!=(const PreOrderIterator& other) const {
        -:  323:        return !stack.empty();
        -:  324:    }
        -:  325:
        -:  326:    template <typename T, size_t K>
        -:  327:    const T& Tree<T, K>::PreOrderIterator::operator*() const {
        -:  328:        return stack.top()->key;
        -:  329:    }
        -:  330:
        -:  331:    template <typename T, size_t K>
        -:  332:    typename Tree<T, K>::PreOrderIterator& Tree<T, K>::PreOrderIterator::operator++() {
        -:  333:        Node* current = stack.top();
        -:  334:        stack.pop();
        -:  335:        for (size_t i = K; i-- > 0;) {
        -:  336:            if (current->children[i]) {
        -:  337:                stack.push(current->children[i]);
        -:  338:            }
        -:  339:        }
        -:  340:        return *this;
        -:  341:    }
        -:  342:
        -:  343:    // InOrderIterator implementation
        -:  344:    template <typename T, size_t K>
        -:  345:    Tree<T, K>::InOrderIterator::InOrderIterator(Node* root) {
        -:  346:        pushLeft(root);
        -:  347:    }
        -:  348:
        -:  349:    //TODO - Edit 
        -:  350:    template <typename T, size_t K>
        -:  351:    bool Tree<T, K>::InOrderIterator::operator!=(const InOrderIterator& other) const {
        -:  352:        return !stack.empty();
        -:  353:    }
        -:  354:    
        -:  355:    template <typename T, size_t K>
        -:  356:    const T& Tree<T, K>::InOrderIterator::operator*() const {
        -:  357:        return stack.top()->key;
        -:  358:    }
        -:  359:
        -:  360:    template <typename T, size_t K>
        -:  361:    typename Tree<T, K>::InOrderIterator& Tree<T, K>::InOrderIterator::operator++() {
        -:  362:        Node* current = stack.top();
        -:  363:        stack.pop();
        -:  364:        pushLeft(current->children[1]); // Assuming binary tree for InOrder
        -:  365:        return *this;
        -:  366:    }
        -:  367:
        -:  368:    template <typename T, size_t K>
        -:  369:    void Tree<T, K>::InOrderIterator::pushLeft(Node* node) {
        -:  370:        while (node) {
        -:  371:            stack.push(node);
        -:  372:            node = node->children[0]; // Assuming binary tree for InOrder
        -:  373:        }
        -:  374:    }
        -:  375:
        -:  376:    // PostOrderIterator implementation
        -:  377:    template <typename T, size_t K>
        -:  378:    Tree<T, K>::PostOrderIterator::PostOrderIterator(Node* root) {
        -:  379:        pushLeft(root);
        -:  380:    }
        -:  381:
        -:  382:    // TODO - Edit 
        -:  383:    template <typename T, size_t K>
        -:  384:    bool Tree<T, K>::PostOrderIterator::operator!=(const PostOrderIterator& other) const {
        -:  385:        return !stack.empty();
        -:  386:    }
        -:  387:
        -:  388:    template <typename T, size_t K>
        -:  389:    const T& Tree<T, K>::PostOrderIterator::operator*() const {
        -:  390:        return stack.top()->key;
        -:  391:    }
        -:  392:
        -:  393:    template <typename T, size_t K>
        -:  394:    typename Tree<T, K>::PostOrderIterator& Tree<T, K>::PostOrderIterator::operator++() {
        -:  395:        Node* current = stack.top();
        -:  396:        stack.pop();
        -:  397:        if (!stack.empty() && stack.top()->children[1] == current) { // Assuming binary tree for PostOrder
        -:  398:            pushLeft(stack.top()->children[1]);
        -:  399:        }
        -:  400:        return *this;
        -:  401:    }
        -:  402:
        -:  403:    template <typename T, size_t K>
        -:  404:    void Tree<T, K>::PostOrderIterator::pushLeft(Node* node) {
        -:  405:        while (node) {
        -:  406:            if (node->children[1]) { // Assuming binary tree for PostOrder
        -:  407:                stack.push(node->children[1]);
        -:  408:            }
        -:  409:            stack.push(node);
        -:  410:            node = node->children[0]; // Assuming binary tree for PostOrder
        -:  411:        }
        -:  412:    }
        -:  413:}
        -:  414:
        -:  415:#endif 
