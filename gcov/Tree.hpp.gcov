        -:    0:Source:Tree.hpp
        -:    1:#ifndef TREE_HPP
        -:    2:#define TREE_HPP
        -:    3:
        -:    4:#include <iostream>
        -:    5:#include <vector>
        -:    6:#include <queue>
        -:    7:#include <stack>
        -:    8:#include <SFML/Graphics.hpp>
        -:    9:
        -:   10:namespace ariel {
        -:   11:
        -:   12:    // Define the Tree class with default - Binary Tree (2 Children per Node)
        -:   13:    template <typename T, size_t K = 2>
        -:   14:    class Tree {
        -:   15:    public:
        -:   16:        
        -:   17:        // Define the Node struct
        -:   18:        struct Node {
        -:   19:            T key;
        -:   20:            Node* children[K];
        -:   21:
       10:   22:            Node(const T& key) : key(key) {
       30:   23:                for (size_t i = 0; i < K; ++i) {
       20:   24:                    children[i] = nullptr;
        -:   25:                }
       10:   26:            }
        -:   27:        };
        -:   28:
        -:   29:        Tree(); // Constructor
        -:   30:        ~Tree();  // Destructor
        -:   31:
        -:   32:        void add_root(const T& key);  // Add root node
        -:   33:        void add_sub_node(Node* parent, const T& key);  // Add sub node
        -:   34:        void display() const;  // Display the tree
        -:   35:        Node* get_root() const;  // Get the root node
        -:   36:
        -:   37:        // Draw the tree 
        -:   38:        void draw(sf::RenderWindow& window) const;
        -:   39:
        -:   40:        // Iterator classes
        -:   41:        class BFSIterator;  // Breadth First Search Iterator
        -:   42:        class DFSIterator;  // Depth First Search Iterator
        -:   43:        class PreOrderIterator;  // PreOrder Iterator
        -:   44:        class InOrderIterator;  // InOrder Iterator
        -:   45:        class PostOrderIterator;  // PostOrder Iterator
        -:   46:
        -:   47:        // Member Function Declarations of the 'Tree' class template
        -:   48:        BFSIterator begin_bfs();  // Begin BFS Iterator
        -:   49:        BFSIterator end_bfs();  // End BFS Iterator
        -:   50:        DFSIterator begin_dfs();  // Begin DFS Iterator
        -:   51:        DFSIterator end_dfs();  // End DFS Iterator
        -:   52:        PreOrderIterator begin_preorder();  // Begin PreOrder Iterator
        -:   53:        PreOrderIterator end_preorder();  // End PreOrder Iterator
        -:   54:        InOrderIterator begin_inorder();  // Begin InOrder Iterator
        -:   55:        InOrderIterator end_inorder();  // End InOrder Iterator
        -:   56:        PostOrderIterator begin_postorder();  // Begin PostOrder Iterator
        -:   57:        PostOrderIterator end_postorder();  // End PostOrder Iterator
        -:   58:
        -:   59:        // Method to transform the tree into a min-heap and return an iterator
        -:   60:        typename Tree<T, K>::BFSIterator myHeap(); // Transform tree into a min-heap and return iterator        
        -:   61:        
        -:   62:    private:
        -:   63:        Node* root;  // Root node - field
        -:   64:
        -:   65:        // Helper functions to display the tree
        -:   66:        void displayHelper(Node* node, int indent) const;
        -:   67:        
        -:   68:        // Helper functions to clear the tree - delete every node in the Tree.
        -:   69:        void clear(Node* node);
        -:   70:
        -:   71:        // Helper function to draw the tree
        -:   72:        void drawNode(sf::RenderWindow& window, Node* node, sf::Vector2f position, float angle, float distance, int depth) const;
        -:   73:
        -:   74:        // Helper function to draw the arrow
        -:   75:        void drawArrow(sf::RenderWindow& window, sf::Vector2f start, sf::Vector2f end) const;  // Add this line
        -:   76:    };
        -:   77:
        -:   78:    // Define the BFSIterator class
        -:   79:    template <typename T, size_t K>
        -:   80:    class Tree<T, K>::BFSIterator {
        -:   81:    public:
        -:   82:        BFSIterator(Node* root);  // BFSIterator constructor
        -:   83:
        -:   84:        // Overloaded operators
        -:   85:        bool operator!=(const BFSIterator& other) const;  // Not equal operator
        -:   86:        const T& operator*() const;  // Dereference operator
        -:   87:        BFSIterator& operator++();      // Increment operator
        -:   88:
        -:   89:    private:
        -:   90:        std::queue<Node*> queue; // Queue to store the nodes
        -:   91:    };
        -:   92:
        -:   93:    // Define the DFSIterator class
        -:   94:    template <typename T, size_t K>
        -:   95:    class Tree<T, K>::DFSIterator {
        -:   96:    public:
        -:   97:        DFSIterator(Node* root);  // DFSIterator constructor
        -:   98:
        -:   99:        // Overloaded operators
        -:  100:        bool operator!=(const DFSIterator& other) const;  // Not equal operator
        -:  101:        const T& operator*() const;  // Dereference operator
        -:  102:        DFSIterator& operator++();  // Increment operator
        -:  103:
        -:  104:    private:
        -:  105:        std::stack<Node*> stack;  // Stack to store the nodes
        -:  106:    };
        -:  107:
        -:  108:    // Define the PreOrderIterator class
        -:  109:    template <typename T, size_t K>
        -:  110:    class Tree<T, K>::PreOrderIterator {
        -:  111:    public:
        -:  112:        PreOrderIterator(Node* root);  // PreOrderIterator constructor
        -:  113:
        -:  114:        // Overloaded operators
        -:  115:        bool operator!=(const PreOrderIterator& other) const;  // Not equal operator
        -:  116:        const T& operator*() const;  // Dereference operator
        -:  117:        PreOrderIterator& operator++();  // Increment operator
        -:  118:
        -:  119:    private:
        -:  120:        std::stack<Node*> stack;  // Stack to store the nodes
        -:  121:    };
        -:  122:
        -:  123:    // Define the InOrderIterator class
        -:  124:    template <typename T, size_t K>
        -:  125:    class Tree<T, K>::InOrderIterator {
        -:  126:    public:
        -:  127:        InOrderIterator(Node* root);  // InOrderIterator constructor
        -:  128:
        -:  129:        // Overloaded operators
        -:  130:        bool operator!=(const InOrderIterator& other) const;  // Not equal operator
        -:  131:        const T& operator*() const;  // Dereference operator
        -:  132:        InOrderIterator& operator++();  // Increment operator
        -:  133:
        -:  134:    private:
        -:  135:        std::stack<Node*> stack;  // Stack to store the nodes
        -:  136:        void pushLeft(Node* node);  // Helper function to push the left nodes to the stack
        -:  137:    };
        -:  138:
        -:  139:    // Define the PostOrderIterator class
        -:  140:    template <typename T, size_t K>
        -:  141:    class Tree<T, K>::PostOrderIterator {
        -:  142:    public:
        -:  143:        PostOrderIterator(Node* root);  // PostOrderIterator constructor
        -:  144:
        -:  145:        // Overloaded operators
        -:  146:        bool operator!=(const PostOrderIterator& other) const;  // Not equal operator
        -:  147:        const T& operator*() const;  // Dereference operator
        -:  148:        PostOrderIterator& operator++();  // Increment operator
        -:  149:
        -:  150:    private:
        -:  151:        std::stack<Node*> stack;  // Stack to store the nodes
        -:  152:        void pushLeft(Node* node);  // Helper function to push the left nodes to the stack
        -:  153:
        -:  154:    };
        -:  155:
        -:  156:} // namespace ariel
        -:  157:
        -:  158:#include "Tree.cpp"
        -:  159:#endif 
